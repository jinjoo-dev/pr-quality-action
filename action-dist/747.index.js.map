{"version":3,"file":"747.index.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1rBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACncA;AACA;AACA;AACA;AACA;AACA;AACA","sources":[".././node_modules/@humanfs/core/src/hfs.js",".././node_modules/@humanfs/core/src/path.js",".././node_modules/@humanfs/core/src/errors.js",".././node_modules/@humanfs/core/src/index.js",".././node_modules/@humanwhocodes/retry/dist/retrier.js",".././node_modules/@humanfs/node/src/node-hfs.js",".././node_modules/@humanfs/node/src/index.js"],"sourcesContent":["/**\n * @fileoverview The main file for the humanfs package.\n * @author Nicholas C. Zakas\n */\n\n/* global URL, TextDecoder, TextEncoder */\n\n//-----------------------------------------------------------------------------\n// Types\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"@humanfs/types\").HfsImpl} HfsImpl */\n/** @typedef {import(\"@humanfs/types\").HfsDirectoryEntry} HfsDirectoryEntry */\n/** @typedef {import(\"@humanfs/types\").HfsWalkEntry} HfsWalkEntry */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst decoder = new TextDecoder();\nconst encoder = new TextEncoder();\n\n/**\n * Error to represent when a method is missing on an impl.\n */\nexport class NoSuchMethodError extends Error {\n\t/**\n\t * Creates a new instance.\n\t * @param {string} methodName The name of the method that was missing.\n\t */\n\tconstructor(methodName) {\n\t\tsuper(`Method \"${methodName}\" does not exist on impl.`);\n\t}\n}\n\n/**\n * Error to represent when a method is not supported on an impl. This happens\n * when a method on `Hfs` is called with one name and the corresponding method\n * on the impl has a different name. (Example: `text()` and `bytes()`.)\n */\nexport class MethodNotSupportedError extends Error {\n\t/**\n\t * Creates a new instance.\n\t * @param {string} methodName The name of the method that was missing.\n\t */\n\tconstructor(methodName) {\n\t\tsuper(`Method \"${methodName}\" is not supported on this impl.`);\n\t}\n}\n\n/**\n * Error to represent when an impl is already set.\n */\nexport class ImplAlreadySetError extends Error {\n\t/**\n\t * Creates a new instance.\n\t */\n\tconstructor() {\n\t\tsuper(`Implementation already set.`);\n\t}\n}\n\n/**\n * Asserts that the given path is a valid file path.\n * @param {any} fileOrDirPath The path to check.\n * @returns {void}\n * @throws {TypeError} When the path is not a non-empty string.\n */\nfunction assertValidFileOrDirPath(fileOrDirPath) {\n\tif (\n\t\t!fileOrDirPath ||\n\t\t(!(fileOrDirPath instanceof URL) && typeof fileOrDirPath !== \"string\")\n\t) {\n\t\tthrow new TypeError(\"Path must be a non-empty string or URL.\");\n\t}\n}\n\n/**\n * Asserts that the given file contents are valid.\n * @param {any} contents The contents to check.\n * @returns {void}\n * @throws {TypeError} When the contents are not a string or ArrayBuffer.\n */\nfunction assertValidFileContents(contents) {\n\tif (\n\t\ttypeof contents !== \"string\" &&\n\t\t!(contents instanceof ArrayBuffer) &&\n\t\t!ArrayBuffer.isView(contents)\n\t) {\n\t\tthrow new TypeError(\n\t\t\t\"File contents must be a string, ArrayBuffer, or ArrayBuffer view.\",\n\t\t);\n\t}\n}\n\n/**\n * Converts the given contents to Uint8Array.\n * @param {any} contents The data to convert.\n * @returns {Uint8Array} The converted Uint8Array.\n * @throws {TypeError} When the contents are not a string or ArrayBuffer.\n */\nfunction toUint8Array(contents) {\n\tif (contents instanceof Uint8Array) {\n\t\treturn contents;\n\t}\n\n\tif (typeof contents === \"string\") {\n\t\treturn encoder.encode(contents);\n\t}\n\n\tif (contents instanceof ArrayBuffer) {\n\t\treturn new Uint8Array(contents);\n\t}\n\n\tif (ArrayBuffer.isView(contents)) {\n\t\tconst bytes = contents.buffer.slice(\n\t\t\tcontents.byteOffset,\n\t\t\tcontents.byteOffset + contents.byteLength,\n\t\t);\n\t\treturn new Uint8Array(bytes);\n\t}\n\tthrow new TypeError(\n\t\t\"Invalid contents type. Expected string or ArrayBuffer.\",\n\t);\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * A class representing a log entry.\n */\nexport class LogEntry {\n\t/**\n\t * The type of log entry.\n\t * @type {string}\n\t */\n\ttype;\n\n\t/**\n\t * The data associated with the log entry.\n\t * @type {any}\n\t */\n\tdata;\n\n\t/**\n\t * The time at which the log entry was created.\n\t * @type {number}\n\t */\n\ttimestamp = Date.now();\n\n\t/**\n\t * Creates a new instance.\n\t * @param {string} type The type of log entry.\n\t * @param {any} [data] The data associated with the log entry.\n\t */\n\tconstructor(type, data) {\n\t\tthis.type = type;\n\t\tthis.data = data;\n\t}\n}\n\n/**\n * A class representing a file system utility library.\n * @implements {HfsImpl}\n */\nexport class Hfs {\n\t/**\n\t * The base implementation for this instance.\n\t * @type {HfsImpl}\n\t */\n\t#baseImpl;\n\n\t/**\n\t * The current implementation for this instance.\n\t * @type {HfsImpl}\n\t */\n\t#impl;\n\n\t/**\n\t * A map of log names to their corresponding entries.\n\t * @type {Map<string,Array<LogEntry>>}\n\t */\n\t#logs = new Map();\n\n\t/**\n\t * Creates a new instance.\n\t * @param {object} options The options for the instance.\n\t * @param {HfsImpl} options.impl The implementation to use.\n\t */\n\tconstructor({ impl }) {\n\t\tthis.#baseImpl = impl;\n\t\tthis.#impl = impl;\n\t}\n\n\t/**\n\t * Logs an entry onto all currently open logs.\n\t * @param {string} methodName The name of the method being called.\n\t * @param {...*} args The arguments to the method.\n\t * @returns {void}\n\t */\n\t#log(methodName, ...args) {\n\t\tfor (const logs of this.#logs.values()) {\n\t\t\tlogs.push(new LogEntry(\"call\", { methodName, args }));\n\t\t}\n\t}\n\n\t/**\n\t * Starts a new log with the given name.\n\t * @param {string} name The name of the log to start;\n\t * @returns {void}\n\t * @throws {Error} When the log already exists.\n\t * @throws {TypeError} When the name is not a non-empty string.\n\t */\n\tlogStart(name) {\n\t\tif (!name || typeof name !== \"string\") {\n\t\t\tthrow new TypeError(\"Log name must be a non-empty string.\");\n\t\t}\n\n\t\tif (this.#logs.has(name)) {\n\t\t\tthrow new Error(`Log \"${name}\" already exists.`);\n\t\t}\n\n\t\tthis.#logs.set(name, []);\n\t}\n\n\t/**\n\t * Ends a log with the given name and returns the entries.\n\t * @param {string} name The name of the log to end.\n\t * @returns {Array<LogEntry>} The entries in the log.\n\t * @throws {Error} When the log does not exist.\n\t */\n\tlogEnd(name) {\n\t\tif (this.#logs.has(name)) {\n\t\t\tconst logs = this.#logs.get(name);\n\t\t\tthis.#logs.delete(name);\n\t\t\treturn logs;\n\t\t}\n\n\t\tthrow new Error(`Log \"${name}\" does not exist.`);\n\t}\n\n\t/**\n\t * Determines if the current implementation is the base implementation.\n\t * @returns {boolean} True if the current implementation is the base implementation.\n\t */\n\tisBaseImpl() {\n\t\treturn this.#impl === this.#baseImpl;\n\t}\n\n\t/**\n\t * Sets the implementation for this instance.\n\t * @param {object} impl The implementation to use.\n\t * @returns {void}\n\t */\n\tsetImpl(impl) {\n\t\tthis.#log(\"implSet\", impl);\n\n\t\tif (this.#impl !== this.#baseImpl) {\n\t\t\tthrow new ImplAlreadySetError();\n\t\t}\n\n\t\tthis.#impl = impl;\n\t}\n\n\t/**\n\t * Resets the implementation for this instance back to its original.\n\t * @returns {void}\n\t */\n\tresetImpl() {\n\t\tthis.#log(\"implReset\");\n\t\tthis.#impl = this.#baseImpl;\n\t}\n\n\t/**\n\t * Asserts that the given method exists on the current implementation.\n\t * @param {string} methodName The name of the method to check.\n\t * @returns {void}\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t */\n\t#assertImplMethod(methodName) {\n\t\tif (typeof this.#impl[methodName] !== \"function\") {\n\t\t\tthrow new NoSuchMethodError(methodName);\n\t\t}\n\t}\n\n\t/**\n\t * Asserts that the given method exists on the current implementation, and if not,\n\t * throws an error with a different method name.\n\t * @param {string} methodName The name of the method to check.\n\t * @param {string} targetMethodName The name of the method that should be reported\n\t *  as an error when methodName does not exist.\n\t * @returns {void}\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t */\n\t#assertImplMethodAlt(methodName, targetMethodName) {\n\t\tif (typeof this.#impl[methodName] !== \"function\") {\n\t\t\tthrow new MethodNotSupportedError(targetMethodName);\n\t\t}\n\t}\n\n\t/**\n\t * Calls the given method on the current implementation.\n\t * @param {string} methodName The name of the method to call.\n\t * @param {...any} args The arguments to the method.\n\t * @returns {any} The return value from the method.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t */\n\t#callImplMethod(methodName, ...args) {\n\t\tthis.#log(methodName, ...args);\n\t\tthis.#assertImplMethod(methodName);\n\t\treturn this.#impl[methodName](...args);\n\t}\n\n\t/**\n\t * Calls the given method on the current implementation and doesn't log the call.\n\t * @param {string} methodName The name of the method to call.\n\t * @param {...any} args The arguments to the method.\n\t * @returns {any} The return value from the method.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t */\n\t#callImplMethodWithoutLog(methodName, ...args) {\n\t\tthis.#assertImplMethod(methodName);\n\t\treturn this.#impl[methodName](...args);\n\t}\n\n\t/**\n\t * Calls the given method on the current implementation but logs a different method name.\n\t * @param {string} methodName The name of the method to call.\n\t * @param {string} targetMethodName The name of the method to log.\n\t * @param {...any} args The arguments to the method.\n\t * @returns {any} The return value from the method.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t */\n\t#callImplMethodAlt(methodName, targetMethodName, ...args) {\n\t\tthis.#log(targetMethodName, ...args);\n\t\tthis.#assertImplMethodAlt(methodName, targetMethodName);\n\t\treturn this.#impl[methodName](...args);\n\t}\n\n\t/**\n\t * Reads the given file and returns the contents as text. Assumes UTF-8 encoding.\n\t * @param {string|URL} filePath The file to read.\n\t * @returns {Promise<string|undefined>} The contents of the file.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t */\n\tasync text(filePath) {\n\t\tassertValidFileOrDirPath(filePath);\n\n\t\tconst result = await this.#callImplMethodAlt(\"bytes\", \"text\", filePath);\n\t\treturn result ? decoder.decode(result) : undefined;\n\t}\n\n\t/**\n\t * Reads the given file and returns the contents as JSON. Assumes UTF-8 encoding.\n\t * @param {string|URL} filePath The file to read.\n\t * @returns {Promise<any|undefined>} The contents of the file as JSON.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {SyntaxError} When the file contents are not valid JSON.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t */\n\tasync json(filePath) {\n\t\tassertValidFileOrDirPath(filePath);\n\n\t\tconst result = await this.#callImplMethodAlt(\"bytes\", \"json\", filePath);\n\t\treturn result ? JSON.parse(decoder.decode(result)) : undefined;\n\t}\n\n\t/**\n\t * Reads the given file and returns the contents as an ArrayBuffer.\n\t * @param {string|URL} filePath The file to read.\n\t * @returns {Promise<ArrayBuffer|undefined>} The contents of the file as an ArrayBuffer.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t * @deprecated Use bytes() instead.\n\t */\n\tasync arrayBuffer(filePath) {\n\t\tassertValidFileOrDirPath(filePath);\n\n\t\tconst result = await this.#callImplMethodAlt(\n\t\t\t\"bytes\",\n\t\t\t\"arrayBuffer\",\n\t\t\tfilePath,\n\t\t);\n\t\treturn result?.buffer;\n\t}\n\n\t/**\n\t * Reads the given file and returns the contents as an Uint8Array.\n\t * @param {string|URL} filePath The file to read.\n\t * @returns {Promise<Uint8Array|undefined>} The contents of the file as an Uint8Array.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t */\n\tasync bytes(filePath) {\n\t\tassertValidFileOrDirPath(filePath);\n\t\treturn this.#callImplMethod(\"bytes\", filePath);\n\t}\n\n\t/**\n\t * Writes the given data to the given file. Creates any necessary directories along the way.\n\t * If the data is a string, UTF-8 encoding is used.\n\t * @param {string|URL} filePath The file to write.\n\t * @param {string|ArrayBuffer|ArrayBufferView} contents The data to write.\n\t * @returns {Promise<void>} A promise that resolves when the file is written.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t */\n\tasync write(filePath, contents) {\n\t\tassertValidFileOrDirPath(filePath);\n\t\tassertValidFileContents(contents);\n\t\tthis.#log(\"write\", filePath, contents);\n\n\t\tlet value = toUint8Array(contents);\n\t\treturn this.#callImplMethodWithoutLog(\"write\", filePath, value);\n\t}\n\n\t/**\n\t * Appends the given data to the given file. Creates any necessary directories along the way.\n\t * If the data is a string, UTF-8 encoding is used.\n\t * @param {string|URL} filePath The file to append to.\n\t * @param {string|ArrayBuffer|ArrayBufferView} contents The data to append.\n\t * @returns {Promise<void>} A promise that resolves when the file is appended to.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t * @throws {TypeError} When the file contents are not a string or ArrayBuffer.\n\t * @throws {Error} When the file cannot be appended to.\n\t */\n\tasync append(filePath, contents) {\n\t\tassertValidFileOrDirPath(filePath);\n\t\tassertValidFileContents(contents);\n\t\tthis.#log(\"append\", filePath, contents);\n\n\t\tlet value = toUint8Array(contents);\n\t\treturn this.#callImplMethodWithoutLog(\"append\", filePath, value);\n\t}\n\n\t/**\n\t * Determines if the given file exists.\n\t * @param {string|URL} filePath The file to check.\n\t * @returns {Promise<boolean>} True if the file exists.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t */\n\tasync isFile(filePath) {\n\t\tassertValidFileOrDirPath(filePath);\n\t\treturn this.#callImplMethod(\"isFile\", filePath);\n\t}\n\n\t/**\n\t * Determines if the given directory exists.\n\t * @param {string|URL} dirPath The directory to check.\n\t * @returns {Promise<boolean>} True if the directory exists.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the directory path is not a non-empty string.\n\t */\n\tasync isDirectory(dirPath) {\n\t\tassertValidFileOrDirPath(dirPath);\n\t\treturn this.#callImplMethod(\"isDirectory\", dirPath);\n\t}\n\n\t/**\n\t * Creates the given directory.\n\t * @param {string|URL} dirPath The directory to create.\n\t * @returns {Promise<void>} A promise that resolves when the directory is created.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the directory path is not a non-empty string.\n\t */\n\tasync createDirectory(dirPath) {\n\t\tassertValidFileOrDirPath(dirPath);\n\t\treturn this.#callImplMethod(\"createDirectory\", dirPath);\n\t}\n\n\t/**\n\t * Deletes the given file or empty directory.\n\t * @param {string|URL} filePath The file to delete.\n\t * @returns {Promise<boolean>} A promise that resolves when the file or\n\t *   directory is deleted, true if the file or directory is deleted, false\n\t *   if the file or directory does not exist.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t */\n\tasync delete(filePath) {\n\t\tassertValidFileOrDirPath(filePath);\n\t\treturn this.#callImplMethod(\"delete\", filePath);\n\t}\n\n\t/**\n\t * Deletes the given file or directory recursively.\n\t * @param {string|URL} dirPath The directory to delete.\n\t * @returns {Promise<boolean>} A promise that resolves when the file or\n\t *   directory is deleted, true if the file or directory is deleted, false\n\t *   if the file or directory does not exist.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the directory path is not a non-empty string.\n\t */\n\tasync deleteAll(dirPath) {\n\t\tassertValidFileOrDirPath(dirPath);\n\t\treturn this.#callImplMethod(\"deleteAll\", dirPath);\n\t}\n\n\t/**\n\t * Returns a list of directory entries for the given path.\n\t * @param {string|URL} dirPath The path to the directory to read.\n\t * @returns {AsyncIterable<HfsDirectoryEntry>} A promise that resolves with the\n\t *   directory entries.\n\t * @throws {TypeError} If the directory path is not a string or URL.\n\t * @throws {Error} If the directory cannot be read.\n\t */\n\tasync *list(dirPath) {\n\t\tassertValidFileOrDirPath(dirPath);\n\t\tyield* await this.#callImplMethod(\"list\", dirPath);\n\t}\n\n\t/**\n\t * Walks a directory using a depth-first traversal and returns the entries\n\t * from the traversal.\n\t * @param {string|URL} dirPath The path to the directory to walk.\n\t * @param {Object} [options] The options for the walk.\n\t * @param {(entry:HfsWalkEntry) => Promise<boolean>|boolean} [options.directoryFilter] A filter function to determine\n\t * \tif a directory's entries should be included in the walk.\n\t * @param {(entry:HfsWalkEntry) => Promise<boolean>|boolean} [options.entryFilter] A filter function to determine if\n\t * \tan entry should be included in the walk.\n\t * @returns {AsyncIterable<HfsWalkEntry>} A promise that resolves with the\n\t * \tdirectory entries.\n\t * @throws {TypeError} If the directory path is not a string or URL.\n\t * @throws {Error} If the directory cannot be read.\n\t */\n\tasync *walk(\n\t\tdirPath,\n\t\t{ directoryFilter = () => true, entryFilter = () => true } = {},\n\t) {\n\t\tassertValidFileOrDirPath(dirPath);\n\t\tthis.#log(\"walk\", dirPath, { directoryFilter, entryFilter });\n\n\t\t// inner function for recursion without additional logging\n\t\tconst walk = async function* (\n\t\t\tdirPath,\n\t\t\t{ directoryFilter, entryFilter, parentPath = \"\", depth = 1 },\n\t\t) {\n\t\t\tlet dirEntries;\n\n\t\t\ttry {\n\t\t\t\tdirEntries = await this.#callImplMethodWithoutLog(\n\t\t\t\t\t\"list\",\n\t\t\t\t\tdirPath,\n\t\t\t\t);\n\t\t\t} catch (error) {\n\t\t\t\t// if the directory does not exist then return an empty array\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// otherwise, rethrow the error\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tfor await (const listEntry of dirEntries) {\n\t\t\t\tconst walkEntry = {\n\t\t\t\t\tpath: listEntry.name,\n\t\t\t\t\tdepth,\n\t\t\t\t\t...listEntry,\n\t\t\t\t};\n\n\t\t\t\tif (parentPath) {\n\t\t\t\t\twalkEntry.path = `${parentPath}/${walkEntry.path}`;\n\t\t\t\t}\n\n\t\t\t\t// first emit the entry but only if the entry filter returns true\n\t\t\t\tlet shouldEmitEntry = entryFilter(walkEntry);\n\t\t\t\tif (shouldEmitEntry.then) {\n\t\t\t\t\tshouldEmitEntry = await shouldEmitEntry;\n\t\t\t\t}\n\n\t\t\t\tif (shouldEmitEntry) {\n\t\t\t\t\tyield walkEntry;\n\t\t\t\t}\n\n\t\t\t\t// if it's a directory then yield the entry and walk the directory\n\t\t\t\tif (listEntry.isDirectory) {\n\t\t\t\t\t// if the directory filter returns false, skip the directory\n\t\t\t\t\tlet shouldWalkDirectory = directoryFilter(walkEntry);\n\t\t\t\t\tif (shouldWalkDirectory.then) {\n\t\t\t\t\t\tshouldWalkDirectory = await shouldWalkDirectory;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!shouldWalkDirectory) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// make sure there's a trailing slash on the directory path before appending\n\t\t\t\t\tconst directoryPath =\n\t\t\t\t\t\tdirPath instanceof URL\n\t\t\t\t\t\t\t? new URL(\n\t\t\t\t\t\t\t\t\tlistEntry.name,\n\t\t\t\t\t\t\t\t\tdirPath.href.endsWith(\"/\")\n\t\t\t\t\t\t\t\t\t\t? dirPath.href\n\t\t\t\t\t\t\t\t\t\t: `${dirPath.href}/`,\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t: `${dirPath.endsWith(\"/\") ? dirPath : `${dirPath}/`}${listEntry.name}`;\n\n\t\t\t\t\tyield* walk(directoryPath, {\n\t\t\t\t\t\tdirectoryFilter,\n\t\t\t\t\t\tentryFilter,\n\t\t\t\t\t\tparentPath: walkEntry.path,\n\t\t\t\t\t\tdepth: depth + 1,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}.bind(this);\n\n\t\tyield* walk(dirPath, { directoryFilter, entryFilter });\n\t}\n\n\t/**\n\t * Returns the size of the given file.\n\t * @param {string|URL} filePath The path to the file to read.\n\t * @returns {Promise<number>} A promise that resolves with the size of the file.\n\t * @throws {TypeError} If the file path is not a string or URL.\n\t * @throws {Error} If the file cannot be read.\n\t */\n\tasync size(filePath) {\n\t\tassertValidFileOrDirPath(filePath);\n\t\treturn this.#callImplMethod(\"size\", filePath);\n\t}\n\n\t/**\n\t * Returns the last modified timestamp of the given file or directory.\n\t * @param {string|URL} fileOrDirPath The path to the file or directory.\n\t * @returns {Promise<Date|undefined>} A promise that resolves with the last modified date\n\t *  or undefined if the file or directory does not exist.\n\t * @throws {TypeError} If the path is not a string or URL.\n\t */\n\tasync lastModified(fileOrDirPath) {\n\t\tassertValidFileOrDirPath(fileOrDirPath);\n\t\treturn this.#callImplMethod(\"lastModified\", fileOrDirPath);\n\t}\n\n\t/**\n\t * Copys a file from one location to another.\n\t * @param {string|URL} source The path to the file to copy.\n\t * @param {string|URL} destination The path to the new file.\n\t * @returns {Promise<void>} A promise that resolves when the file is copied.\n\t * @throws {TypeError} If the file path is not a string or URL.\n\t * @throws {Error} If the file cannot be copied.\n\t */\n\tasync copy(source, destination) {\n\t\tassertValidFileOrDirPath(source);\n\t\tassertValidFileOrDirPath(destination);\n\t\treturn this.#callImplMethod(\"copy\", source, destination);\n\t}\n\n\t/**\n\t * Copies a file or directory from one location to another.\n\t * @param {string|URL} source The path to the file or directory to copy.\n\t * @param {string|URL} destination The path to copy the file or directory to.\n\t * @returns {Promise<void>} A promise that resolves when the file or directory is\n\t * copied.\n\t * @throws {TypeError} If the directory path is not a string or URL.\n\t * @throws {Error} If the directory cannot be copied.\n\t */\n\tasync copyAll(source, destination) {\n\t\tassertValidFileOrDirPath(source);\n\t\tassertValidFileOrDirPath(destination);\n\t\treturn this.#callImplMethod(\"copyAll\", source, destination);\n\t}\n\n\t/**\n\t * Moves a file from the source path to the destination path.\n\t * @param {string|URL} source The location of the file to move.\n\t * @param {string|URL} destination The destination of the file to move.\n\t * @returns {Promise<void>} A promise that resolves when the move is complete.\n\t * @throws {TypeError} If the file or directory paths are not strings.\n\t * @throws {Error} If the file or directory cannot be moved.\n\t */\n\tasync move(source, destination) {\n\t\tassertValidFileOrDirPath(source);\n\t\tassertValidFileOrDirPath(destination);\n\t\treturn this.#callImplMethod(\"move\", source, destination);\n\t}\n\n\t/**\n\t * Moves a file or directory from one location to another.\n\t * @param {string|URL} source The path to the file or directory to move.\n\t * @param {string|URL} destination The path to move the file or directory to.\n\t * @returns {Promise<void>} A promise that resolves when the file or directory is\n\t * moved.\n\t * @throws {TypeError} If the source is not a string or URL.\n\t * @throws {TypeError} If the destination is not a string or URL.\n\t * @throws {Error} If the file or directory cannot be moved.\n\t */\n\tasync moveAll(source, destination) {\n\t\tassertValidFileOrDirPath(source);\n\t\tassertValidFileOrDirPath(destination);\n\t\treturn this.#callImplMethod(\"moveAll\", source, destination);\n\t}\n}\n","/**\n * @fileoverview The Path class.\n * @author Nicholas C. Zakas\n */\n\n/* globals URL */\n\n//-----------------------------------------------------------------------------\n// Types\n//-----------------------------------------------------------------------------\n\n/** @typedef{import(\"@humanfs/types\").HfsImpl} HfsImpl */\n/** @typedef{import(\"@humanfs/types\").HfsDirectoryEntry} HfsDirectoryEntry */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Normalizes a path to use forward slashes.\n * @param {string} filePath The path to normalize.\n * @returns {string} The normalized path.\n */\nfunction normalizePath(filePath) {\n\tlet startIndex = 0;\n\tlet endIndex = filePath.length;\n\n\tif (/[a-z]:\\//i.test(filePath)) {\n\t\tstartIndex = 3;\n\t}\n\n\tif (filePath.startsWith(\"./\")) {\n\t\tstartIndex = 2;\n\t}\n\n\tif (filePath.startsWith(\"/\")) {\n\t\tstartIndex = 1;\n\t}\n\n\tif (filePath.endsWith(\"/\")) {\n\t\tendIndex = filePath.length - 1;\n\t}\n\n\treturn filePath.slice(startIndex, endIndex).replace(/\\\\/g, \"/\");\n}\n\n/**\n * Asserts that the given name is a non-empty string, no equal to \".\" or \"..\",\n * and does not contain a forward slash or backslash.\n * @param {string} name The name to check.\n * @returns {void}\n * @throws {TypeError} When name is not valid.\n */\nfunction assertValidName(name) {\n\tif (typeof name !== \"string\") {\n\t\tthrow new TypeError(\"name must be a string\");\n\t}\n\n\tif (!name) {\n\t\tthrow new TypeError(\"name cannot be empty\");\n\t}\n\n\tif (name === \".\") {\n\t\tthrow new TypeError(`name cannot be \".\"`);\n\t}\n\n\tif (name === \"..\") {\n\t\tthrow new TypeError(`name cannot be \"..\"`);\n\t}\n\n\tif (name.includes(\"/\") || name.includes(\"\\\\\")) {\n\t\tthrow new TypeError(\n\t\t\t`name cannot contain a slash or backslash: \"${name}\"`,\n\t\t);\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\nexport class Path {\n\t/**\n\t * The steps in the path.\n\t * @type {Array<string>}\n\t */\n\t#steps;\n\n\t/**\n\t * Creates a new instance.\n\t * @param {Iterable<string>} [steps] The steps to use for the path.\n\t * @throws {TypeError} When steps is not iterable.\n\t */\n\tconstructor(steps = []) {\n\t\tif (typeof steps[Symbol.iterator] !== \"function\") {\n\t\t\tthrow new TypeError(\"steps must be iterable\");\n\t\t}\n\n\t\tthis.#steps = [...steps];\n\t\tthis.#steps.forEach(assertValidName);\n\t}\n\n\t/**\n\t * Adds steps to the end of the path.\n\t * @param  {...string} steps The steps to add to the path.\n\t * @returns {void}\n\t */\n\tpush(...steps) {\n\t\tsteps.forEach(assertValidName);\n\t\tthis.#steps.push(...steps);\n\t}\n\n\t/**\n\t * Removes the last step from the path.\n\t * @returns {string} The last step in the path.\n\t */\n\tpop() {\n\t\treturn this.#steps.pop();\n\t}\n\n\t/**\n\t * Returns an iterator for steps in the path.\n\t * @returns {IterableIterator<string>} An iterator for the steps in the path.\n\t */\n\tsteps() {\n\t\treturn this.#steps.values();\n\t}\n\n\t/**\n\t * Returns an iterator for the steps in the path.\n\t * @returns {IterableIterator<string>} An iterator for the steps in the path.\n\t */\n\t[Symbol.iterator]() {\n\t\treturn this.steps();\n\t}\n\n\t/**\n\t * Retrieves the name (the last step) of the path.\n\t * @type {string}\n\t */\n\tget name() {\n\t\treturn this.#steps[this.#steps.length - 1];\n\t}\n\n\t/**\n\t * Sets the name (the last step) of the path.\n\t * @type {string}\n\t */\n\tset name(value) {\n\t\tassertValidName(value);\n\t\tthis.#steps[this.#steps.length - 1] = value;\n\t}\n\n\t/**\n\t * Retrieves the size of the path.\n\t * @type {number}\n\t */\n\tget size() {\n\t\treturn this.#steps.length;\n\t}\n\n\t/**\n\t * Returns the path as a string.\n\t * @returns {string} The path as a string.\n\t */\n\ttoString() {\n\t\treturn this.#steps.join(\"/\");\n\t}\n\n\t/**\n\t * Creates a new path based on the argument type. If the argument is a string,\n\t * it is assumed to be a file or directory path and is converted to a Path\n\t * instance. If the argument is a URL, it is assumed to be a file URL and is\n\t * converted to a Path instance. If the argument is a Path instance, it is\n\t * copied into a new Path instance. If the argument is an array, it is assumed\n\t * to be the steps of a path and is used to create a new Path instance.\n\t * @param {string|URL|Path|Array<string>} pathish The value to convert to a Path instance.\n\t * @returns {Path} A new Path instance.\n\t * @throws {TypeError} When pathish is not a string, URL, Path, or Array.\n\t * @throws {TypeError} When pathish is a string and is empty.\n\t */\n\tstatic from(pathish) {\n\t\tif (typeof pathish === \"string\") {\n\t\t\tif (!pathish) {\n\t\t\t\tthrow new TypeError(\"argument cannot be empty\");\n\t\t\t}\n\n\t\t\treturn Path.fromString(pathish);\n\t\t}\n\n\t\tif (pathish instanceof URL) {\n\t\t\treturn Path.fromURL(pathish);\n\t\t}\n\n\t\tif (pathish instanceof Path || Array.isArray(pathish)) {\n\t\t\treturn new Path(pathish);\n\t\t}\n\n\t\tthrow new TypeError(\"argument must be a string, URL, Path, or Array\");\n\t}\n\n\t/**\n\t * Creates a new Path instance from a string.\n\t * @param {string} fileOrDirPath The file or directory path to convert.\n\t * @returns {Path} A new Path instance.\n\t * @deprecated Use Path.from() instead.\n\t */\n\tstatic fromString(fileOrDirPath) {\n\t\treturn new Path(normalizePath(fileOrDirPath).split(\"/\"));\n\t}\n\n\t/**\n\t * Creates a new Path instance from a URL.\n\t * @param {URL} url The URL to convert.\n\t * @returns {Path} A new Path instance.\n\t * @throws {TypeError} When url is not a URL instance.\n\t * @throws {TypeError} When url.pathname is empty.\n\t * @throws {TypeError} When url.protocol is not \"file:\".\n\t * @deprecated Use Path.from() instead.\n\t */\n\tstatic fromURL(url) {\n\t\tif (!(url instanceof URL)) {\n\t\t\tthrow new TypeError(\"url must be a URL instance\");\n\t\t}\n\n\t\tif (!url.pathname || url.pathname === \"/\") {\n\t\t\tthrow new TypeError(\"url.pathname cannot be empty\");\n\t\t}\n\n\t\tif (url.protocol !== \"file:\") {\n\t\t\tthrow new TypeError(`url.protocol must be \"file:\"`);\n\t\t}\n\n\t\t// Remove leading slash in pathname\n\t\treturn new Path(normalizePath(url.pathname.slice(1)).split(\"/\"));\n\t}\n}\n","/**\n * @fileoverview Common error classes\n * @author Nicholas C. Zakas\n */\n\n/**\n * Error thrown when a file or directory is not found.\n */\nexport class NotFoundError extends Error {\n\t/**\n\t * Name of the error class.\n\t * @type {string}\n\t */\n\tname = \"NotFoundError\";\n\n\t/**\n\t * Error code.\n\t * @type {string}\n\t */\n\tcode = \"ENOENT\";\n\n\t/**\n\t * Creates a new instance.\n\t * @param {string} message The error message.\n\t */\n\tconstructor(message) {\n\t\tsuper(`ENOENT: No such file or directory, ${message}`);\n\t}\n}\n\n/**\n * Error thrown when an operation is not permitted.\n */\nexport class PermissionError extends Error {\n\t/**\n\t * Name of the error class.\n\t * @type {string}\n\t */\n\tname = \"PermissionError\";\n\n\t/**\n\t * Error code.\n\t * @type {string}\n\t */\n\tcode = \"EPERM\";\n\n\t/**\n\t * Creates a new instance.\n\t * @param {string} message The error message.\n\t */\n\tconstructor(message) {\n\t\tsuper(`EPERM: Operation not permitted, ${message}`);\n\t}\n}\n\n/**\n * Error thrown when an operation is not allowed on a directory.\n */\n\nexport class DirectoryError extends Error {\n\t/**\n\t * Name of the error class.\n\t * @type {string}\n\t */\n\tname = \"DirectoryError\";\n\n\t/**\n\t * Error code.\n\t * @type {string}\n\t */\n\tcode = \"EISDIR\";\n\n\t/**\n\t * Creates a new instance.\n\t * @param {string} message The error message.\n\t */\n\tconstructor(message) {\n\t\tsuper(`EISDIR: Illegal operation on a directory, ${message}`);\n\t}\n}\n\n/**\n * Error thrown when a directory is not empty.\n */\nexport class NotEmptyError extends Error {\n\t/**\n\t * Name of the error class.\n\t * @type {string}\n\t */\n\tname = \"NotEmptyError\";\n\n\t/**\n\t * Error code.\n\t * @type {string}\n\t */\n\tcode = \"ENOTEMPTY\";\n\n\t/**\n\t * Creates a new instance.\n\t * @param {string} message The error message.\n\t */\n\tconstructor(message) {\n\t\tsuper(`ENOTEMPTY: Directory not empty, ${message}`);\n\t}\n}\n","/**\n * @fileoverview API entrypoint for hfs/core\n * @author Nicholas C. Zakas\n */\n\nexport { Hfs } from \"./hfs.js\";\nexport { Path } from \"./path.js\";\nexport * from \"./errors.js\";\n","// @ts-self-types=\"./retrier.d.ts\"\n/**\n * @fileoverview A utility for retrying failed async method calls.\n */\n\n/* global setTimeout, clearTimeout */\n\n//-----------------------------------------------------------------------------\n// Constants\n//-----------------------------------------------------------------------------\n\nconst MAX_TASK_TIMEOUT = 60000;\nconst MAX_TASK_DELAY = 100;\nconst MAX_CONCURRENCY = 1000;\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Logs a message to the console if the DEBUG environment variable is set.\n * @param {string} message The message to log.\n * @returns {void}\n */\nfunction debug(message) {\n    if (globalThis?.process?.env.DEBUG === \"@hwc/retry\") {\n        console.debug(message);\n    }\n}\n\n/*\n * The following logic has been extracted from graceful-fs.\n *\n * The ISC License\n *\n * Copyright (c) 2011-2023 Isaac Z. Schlueter, Ben Noordhuis, and Contributors\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR\n * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n/**\n * Checks if it is time to retry a task based on the timestamp and last attempt time.\n * @param {RetryTask} task The task to check.\n * @param {number} maxDelay The maximum delay for the queue.\n * @returns {boolean} true if it is time to retry, false otherwise.\n */\nfunction isTimeToRetry(task, maxDelay) {\n    const timeSinceLastAttempt = Date.now() - task.lastAttempt;\n    const timeSinceStart = Math.max(task.lastAttempt - task.timestamp, 1);\n    const desiredDelay = Math.min(timeSinceStart * 1.2, maxDelay);\n\n    return timeSinceLastAttempt >= desiredDelay;\n}\n\n/**\n * Checks if it is time to bail out based on the given timestamp.\n * @param {RetryTask} task The task to check.\n * @param {number} timeout The timeout for the queue.\n * @returns {boolean} true if it is time to bail, false otherwise.\n */\nfunction isTimeToBail(task, timeout) {\n    return task.age > timeout;\n}\n\n/**\n * Creates a new promise with resolve and reject functions.\n * @returns {{promise:Promise<any>, resolve:(value:any) => any, reject: (value:any) => any}} A new promise.\n */\nfunction createPromise() {\n    if (Promise.withResolvers) {\n        return Promise.withResolvers();\n    }\n\n    let resolve, reject;\n\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n\n    if (resolve === undefined || reject === undefined) {\n        throw new Error(\"Promise executor did not initialize resolve or reject.\");\n    }\n\n    return { promise, resolve, reject };\n}\n\n\n/**\n * A class to represent a task in the retry queue.\n */\nclass RetryTask {\n\n    /**\n     * The unique ID for the task.\n     * @type {string}\n     */\n    id = Math.random().toString(36).slice(2);\n\n    /**\n     * The function to call.\n     * @type {Function}\n     */\n    fn;\n\n    /**\n     * The error that was thrown.\n     * @type {Error}\n     */\n    error;\n    \n    /**\n     * The timestamp of the task.\n     * @type {number}\n     */\n    timestamp = Date.now();\n\n    /**\n     * The timestamp of the last attempt.\n     * @type {number}\n     */\n    lastAttempt = this.timestamp;\n\n    /**\n     * The resolve function for the promise.\n     * @type {Function}\n     */\n    resolve;\n\n    /**\n     * The reject function for the promise.\n     * @type {Function}\n     */\n    reject;\n\n    /**\n     * The AbortSignal to monitor for cancellation.\n     * @type {AbortSignal|undefined}\n     */\n    signal;\n\n    /**\n     * Creates a new instance.\n     * @param {Function} fn The function to call.\n     * @param {Error} error The error that was thrown.\n     * @param {Function} resolve The resolve function for the promise.\n     * @param {Function} reject The reject function for the promise.\n     * @param {AbortSignal|undefined} signal The AbortSignal to monitor for cancellation.\n     */\n    constructor(fn, error, resolve, reject, signal) {\n        this.fn = fn;\n        this.error = error;\n        this.timestamp = Date.now();\n        this.lastAttempt = Date.now();\n        this.resolve = resolve;\n        this.reject = reject;\n        this.signal = signal;\n    }\n    \n    /**\n     * Gets the age of the task.\n     * @returns {number} The age of the task in milliseconds.\n     * @readonly\n     */\n    get age() {\n        return Date.now() - this.timestamp;\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * A class that manages a queue of retry jobs.\n */\nclass Retrier {\n\n    /**\n     * Represents the queue for processing tasks.\n     * @type {Array<RetryTask>}\n     */\n    #retrying = [];\n\n    /**\n     * Represents the queue for pending tasks.\n     * @type {Array<Function>}\n     */\n    #pending = [];\n\n    /**\n     * The number of tasks currently being processed.\n     * @type {number}\n     */\n    #working = 0;\n\n    /**\n     * The timeout for the queue.\n     * @type {number}\n     */\n    #timeout;\n\n    /**\n     * The maximum delay for the queue.\n     * @type {number}\n     */\n    #maxDelay;\n\n    /**\n     * The setTimeout() timer ID.\n     * @type {NodeJS.Timeout|undefined}\n     */\n    #timerId;\n\n    /**\n     * The function to call.\n     * @type {Function}\n     */\n    #check;\n\n    /**\n     * The maximum number of concurrent tasks.\n     * @type {number}\n     */\n    #concurrency;\n\n    /**\n     * Creates a new instance.\n     * @param {Function} check The function to call.\n     * @param {object} [options] The options for the instance.\n     * @param {number} [options.timeout] The timeout for the queue.\n     * @param {number} [options.maxDelay] The maximum delay for the queue.\n     * @param {number} [options.concurrency] The maximum number of concurrent tasks.\n     */\n    constructor(check, { timeout = MAX_TASK_TIMEOUT, maxDelay = MAX_TASK_DELAY, concurrency = MAX_CONCURRENCY } = {}) {\n\n        if (typeof check !== \"function\") {\n            throw new Error(\"Missing function to check errors\");\n        }\n\n        this.#check = check;\n        this.#timeout = timeout;\n        this.#maxDelay = maxDelay;\n        this.#concurrency = concurrency;\n    }\n\n    /**\n     * Gets the number of tasks waiting to be retried.\n     * @returns {number} The number of tasks in the retry queue.\n     */\n    get retrying() {\n        return this.#retrying.length;\n    }\n\n    /**\n     * Gets the number of tasks waiting to be processed in the pending queue.\n     * @returns {number} The number of tasks in the pending queue.\n     */\n    get pending() {\n        return this.#pending.length;\n    }\n\n    /**\n     * Gets the number of tasks currently being processed.\n     * @returns {number} The number of tasks currently being processed.\n     */\n    get working() {\n        return this.#working;\n    }\n\n    /**\n     * Calls the function and retries if it fails.\n     * @param {Function} fn The function to call.\n     * @param {Object} options The options for the job.\n     * @param {AbortSignal} [options.signal] The AbortSignal to monitor for cancellation.\n     * @param {Promise<any>} options.promise The promise to return when the function settles.\n     * @param {Function} options.resolve The resolve function for the promise.\n     * @param {Function} options.reject The reject function for the promise.\n     * @returns {Promise<any>} A promise that resolves when the function is\n     * called successfully.\n     */\n    #call(fn, { signal, promise, resolve, reject }) {\n\n        let result;\n\n        try {\n            result = fn();\n        } catch (/** @type {any} */ error) {\n            reject(new Error(`Synchronous error: ${error.message}`, { cause: error }));\n            return promise;\n        }\n\n        // if the result is not a promise then reject an error\n        if (!result || typeof result.then !== \"function\") {\n            reject(new Error(\"Result is not a promise.\"));\n            return promise;\n        }\n\n        this.#working++;\n        promise.finally(() => {\n            this.#working--;\n            this.#processPending();\n        })\n        // `promise.finally` creates a new promise that may be rejected, so it must be handled.\n            .catch(() => { });\n\n        // call the original function and catch any ENFILE or EMFILE errors\n        Promise.resolve(result)\n            .then(value => {\n                debug(\"Function called successfully without retry.\");\n                resolve(value);\n            })\n            .catch(error => {\n                if (!this.#check(error)) {\n                    reject(error);\n                    return;\n                }\n\n                const task = new RetryTask(fn, error, resolve, reject, signal);\n                \n                debug(`Function failed, queuing for retry with task ${task.id}.`);\n                this.#retrying.push(task);\n\n                signal?.addEventListener(\"abort\", () => {\n                    debug(`Task ${task.id} was aborted due to AbortSignal.`);\n                    reject(signal.reason);\n                });\n\n                this.#processQueue();\n            });\n        \n        return promise;\n    }\n\n    /**\n     * Adds a new retry job to the queue.\n     * @template {(...args: unknown[]) => Promise<unknown>} Func\n     * @template {Awaited<ReturnType<Func>>} RetVal\n     * @param {Func} fn The function to call.\n     * @param {object} [options] The options for the job.\n     * @param {AbortSignal} [options.signal] The AbortSignal to monitor for cancellation.\n     * @returns {Promise<RetVal>} A promise that resolves when the queue is processed.\n     */\n    retry(fn, { signal } = {}) {\n\n        signal?.throwIfAborted();\n\n        const { promise, resolve, reject } = createPromise();\n\n        this.#pending.push(() => this.#call(fn, { signal, promise, resolve, reject }));\n        this.#processPending();\n        \n        return promise;\n    }\n\n\n    /**\n     * Processes the pending queue and the retry queue.\n     * @returns {void}\n     */\n    #processAll() {\n        if (this.pending) {\n            this.#processPending();\n        }\n\n        if (this.retrying) {\n            this.#processQueue();\n        }\n    }\n\n    /**\n     * Processes the pending queue to see which tasks can be started.\n     * @returns {void}\n     */\n    #processPending() {\n\n        debug(`Processing pending tasks: ${this.pending} pending, ${this.working} working.`);\n\n        const available = this.#concurrency - this.working;\n\n        if (available <= 0) {\n            return;\n        }\n\n        const count = Math.min(this.pending, available);\n\n        for (let i = 0; i < count; i++) {\n            const task = this.#pending.shift();\n            task?.();\n        }\n\n        debug(`Processed pending tasks: ${this.pending} pending, ${this.working} working.`);\n    }\n\n    /**\n     * Processes the queue.\n     * @returns {void}\n     */\n    #processQueue() {\n        // clear any timer because we're going to check right now\n        clearTimeout(this.#timerId);\n        this.#timerId = undefined;\n\n        debug(`Processing retry queue: ${this.retrying} retrying, ${this.working} working.`);\n\n        const processAgain = () => {\n            this.#timerId = setTimeout(() => this.#processAll(), 0);\n        };\n\n        // if there's nothing in the queue, we're done\n        const task = this.#retrying.shift();\n        if (!task) {\n            debug(\"Queue is empty, exiting.\");\n\n            if (this.pending) {\n                processAgain();\n            }\n            return;\n        }\n\n        // if it's time to bail, then bail\n        if (isTimeToBail(task, this.#timeout)) {\n            debug(`Task ${task.id} was abandoned due to timeout.`);\n            task.reject(task.error);\n            processAgain();\n            return;\n        }\n\n        // if it's not time to retry, then wait and try again\n        if (!isTimeToRetry(task, this.#maxDelay)) {\n            debug(`Task ${task.id} is not ready to retry, skipping.`);\n            this.#retrying.push(task);\n            processAgain();\n            return;\n        }\n\n        // otherwise, try again\n        task.lastAttempt = Date.now();\n        \n        // Promise.resolve needed in case it's a thenable but not a Promise\n        Promise.resolve(task.fn())\n            // @ts-ignore because we know it's any\n            .then(result => {\n                debug(`Task ${task.id} succeeded after ${task.age}ms.`);\n                task.resolve(result);\n            })\n\n            // @ts-ignore because we know it's any\n            .catch(error => {\n                if (!this.#check(error)) {\n                    debug(`Task ${task.id} failed with non-retryable error: ${error.message}.`);\n                    task.reject(error);\n                    return;\n                }\n\n                // update the task timestamp and push to back of queue to try again\n                task.lastAttempt = Date.now();\n                this.#retrying.push(task);\n                debug(`Task ${task.id} failed, requeueing to try again.`);\n            })\n            .finally(() => {\n                this.#processAll();\n            });\n    }\n}\n\nexport { Retrier };\n","/**\n * @fileoverview The main file for the hfs package.\n * @author Nicholas C. Zakas\n */\n/* global Buffer:readonly, URL */\n\n//-----------------------------------------------------------------------------\n// Types\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"@humanfs/types\").HfsImpl} HfsImpl */\n/** @typedef {import(\"@humanfs/types\").HfsDirectoryEntry} HfsDirectoryEntry */\n/** @typedef {import(\"node:fs/promises\")} Fsp */\n/** @typedef {import(\"fs\").Dirent} Dirent */\n\n//-----------------------------------------------------------------------------\n// Imports\n//-----------------------------------------------------------------------------\n\nimport { Hfs } from \"@humanfs/core\";\nimport path from \"node:path\";\nimport { Retrier } from \"@humanwhocodes/retry\";\nimport nativeFsp from \"node:fs/promises\";\nimport { fileURLToPath } from \"node:url\";\n\n//-----------------------------------------------------------------------------\n// Constants\n//-----------------------------------------------------------------------------\n\nconst RETRY_ERROR_CODES = new Set([\"ENFILE\", \"EMFILE\"]);\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * A class representing a directory entry.\n * @implements {HfsDirectoryEntry}\n */\nclass NodeHfsDirectoryEntry {\n\t/**\n\t * The name of the directory entry.\n\t * @type {string}\n\t */\n\tname;\n\n\t/**\n\t * True if the entry is a file.\n\t * @type {boolean}\n\t */\n\tisFile;\n\n\t/**\n\t * True if the entry is a directory.\n\t * @type {boolean}\n\t */\n\tisDirectory;\n\n\t/**\n\t * True if the entry is a symbolic link.\n\t * @type {boolean}\n\t */\n\tisSymlink;\n\n\t/**\n\t * Creates a new instance.\n\t * @param {Dirent} dirent The directory entry to wrap.\n\t */\n\tconstructor(dirent) {\n\t\tthis.name = dirent.name;\n\t\tthis.isFile = dirent.isFile();\n\t\tthis.isDirectory = dirent.isDirectory();\n\t\tthis.isSymlink = dirent.isSymbolicLink();\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * A class representing the Node.js implementation of Hfs.\n * @implements {HfsImpl}\n */\nexport class NodeHfsImpl {\n\t/**\n\t * The file system module to use.\n\t * @type {Fsp}\n\t */\n\t#fsp;\n\n\t/**\n\t * The retryer object used for retrying operations.\n\t * @type {Retrier}\n\t */\n\t#retrier;\n\n\t/**\n\t * Creates a new instance.\n\t * @param {object} [options] The options for the instance.\n\t * @param {Fsp} [options.fsp] The file system module to use.\n\t */\n\tconstructor({ fsp = nativeFsp } = {}) {\n\t\tthis.#fsp = fsp;\n\t\tthis.#retrier = new Retrier(error => RETRY_ERROR_CODES.has(error.code));\n\t}\n\n\t/**\n\t * Reads a file and returns the contents as an Uint8Array.\n\t * @param {string|URL} filePath The path to the file to read.\n\t * @returns {Promise<Uint8Array|undefined>} A promise that resolves with the contents\n\t *    of the file or undefined if the file doesn't exist.\n\t * @throws {Error} If the file cannot be read.\n\t * @throws {TypeError} If the file path is not a string.\n\t */\n\tbytes(filePath) {\n\t\treturn this.#retrier\n\t\t\t.retry(() => this.#fsp.readFile(filePath))\n\t\t\t.then(buffer => new Uint8Array(buffer.buffer))\n\t\t\t.catch(error => {\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Writes a value to a file. If the value is a string, UTF-8 encoding is used.\n\t * @param {string|URL} filePath The path to the file to write.\n\t * @param {Uint8Array} contents The contents to write to the\n\t *   file.\n\t * @returns {Promise<void>} A promise that resolves when the file is\n\t *  written.\n\t * @throws {TypeError} If the file path is not a string.\n\t * @throws {Error} If the file cannot be written.\n\t */\n\tasync write(filePath, contents) {\n\t\tconst value = Buffer.from(contents);\n\n\t\treturn this.#retrier\n\t\t\t.retry(() => this.#fsp.writeFile(filePath, value))\n\t\t\t.catch(error => {\n\t\t\t\t// the directory may not exist, so create it\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\tconst dirPath = path.dirname(\n\t\t\t\t\t\tfilePath instanceof URL\n\t\t\t\t\t\t\t? fileURLToPath(filePath)\n\t\t\t\t\t\t\t: filePath,\n\t\t\t\t\t);\n\n\t\t\t\t\treturn this.#fsp\n\t\t\t\t\t\t.mkdir(dirPath, { recursive: true })\n\t\t\t\t\t\t.then(() => this.#fsp.writeFile(filePath, value));\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Appends a value to a file. If the value is a string, UTF-8 encoding is used.\n\t * @param {string|URL} filePath The path to the file to append to.\n\t * @param {Uint8Array} contents The contents to append to the\n\t *  file.\n\t * @returns {Promise<void>} A promise that resolves when the file is\n\t * written.\n\t * @throws {TypeError} If the file path is not a string.\n\t * @throws {Error} If the file cannot be appended to.\n\t */\n\tasync append(filePath, contents) {\n\t\tconst value = Buffer.from(contents);\n\n\t\treturn this.#retrier\n\t\t\t.retry(() => this.#fsp.appendFile(filePath, value))\n\t\t\t.catch(error => {\n\t\t\t\t// the directory may not exist, so create it\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\tconst dirPath = path.dirname(\n\t\t\t\t\t\tfilePath instanceof URL\n\t\t\t\t\t\t\t? fileURLToPath(filePath)\n\t\t\t\t\t\t\t: filePath,\n\t\t\t\t\t);\n\n\t\t\t\t\treturn this.#fsp\n\t\t\t\t\t\t.mkdir(dirPath, { recursive: true })\n\t\t\t\t\t\t.then(() => this.#fsp.appendFile(filePath, value));\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Checks if a file exists.\n\t * @param {string|URL} filePath The path to the file to check.\n\t * @returns {Promise<boolean>} A promise that resolves with true if the\n\t *    file exists or false if it does not.\n\t * @throws {Error} If the operation fails with a code other than ENOENT.\n\t */\n\tisFile(filePath) {\n\t\treturn this.#fsp\n\t\t\t.stat(filePath)\n\t\t\t.then(stat => stat.isFile())\n\t\t\t.catch(error => {\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Checks if a directory exists.\n\t * @param {string|URL} dirPath The path to the directory to check.\n\t * @returns {Promise<boolean>} A promise that resolves with true if the\n\t *    directory exists or false if it does not.\n\t * @throws {Error} If the operation fails with a code other than ENOENT.\n\t */\n\tisDirectory(dirPath) {\n\t\treturn this.#fsp\n\t\t\t.stat(dirPath)\n\t\t\t.then(stat => stat.isDirectory())\n\t\t\t.catch(error => {\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Creates a directory recursively.\n\t * @param {string|URL} dirPath The path to the directory to create.\n\t * @returns {Promise<void>} A promise that resolves when the directory is\n\t *   created.\n\t */\n\tasync createDirectory(dirPath) {\n\t\tawait this.#fsp.mkdir(dirPath, { recursive: true });\n\t}\n\n\t/**\n\t * Deletes a file or empty directory.\n\t * @param {string|URL} fileOrDirPath The path to the file or directory to\n\t *   delete.\n\t * @returns {Promise<boolean>} A promise that resolves when the file or\n\t *   directory is deleted, true if the file or directory is deleted, false\n\t *   if the file or directory does not exist.\n\t * @throws {TypeError} If the file or directory path is not a string.\n\t * @throws {Error} If the file or directory cannot be deleted.\n\t */\n\tdelete(fileOrDirPath) {\n\t\treturn this.#fsp\n\t\t\t.rm(fileOrDirPath)\n\t\t\t.then(() => true)\n\t\t\t.catch(error => {\n\t\t\t\tif (error.code === \"ERR_FS_EISDIR\") {\n\t\t\t\t\treturn this.#fsp.rmdir(fileOrDirPath).then(() => true);\n\t\t\t\t}\n\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Deletes a file or directory recursively.\n\t * @param {string|URL} fileOrDirPath The path to the file or directory to\n\t *   delete.\n\t * @returns {Promise<boolean>} A promise that resolves when the file or\n\t *   directory is deleted, true if the file or directory is deleted, false\n\t *   if the file or directory does not exist.\n\t * @throws {TypeError} If the file or directory path is not a string.\n\t * @throws {Error} If the file or directory cannot be deleted.\n\t */\n\tdeleteAll(fileOrDirPath) {\n\t\treturn this.#fsp\n\t\t\t.rm(fileOrDirPath, { recursive: true })\n\t\t\t.then(() => true)\n\t\t\t.catch(error => {\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Returns a list of directory entries for the given path.\n\t * @param {string|URL} dirPath The path to the directory to read.\n\t * @returns {AsyncIterable<HfsDirectoryEntry>} A promise that resolves with the\n\t *   directory entries.\n\t * @throws {TypeError} If the directory path is not a string.\n\t * @throws {Error} If the directory cannot be read.\n\t */\n\tasync *list(dirPath) {\n\t\tconst entries = await this.#fsp.readdir(dirPath, {\n\t\t\twithFileTypes: true,\n\t\t});\n\n\t\tfor (const entry of entries) {\n\t\t\tyield new NodeHfsDirectoryEntry(entry);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the size of a file. This method handles ENOENT errors\n\t * and returns undefined in that case.\n\t * @param {string|URL} filePath The path to the file to read.\n\t * @returns {Promise<number|undefined>} A promise that resolves with the size of the\n\t *  file in bytes or undefined if the file doesn't exist.\n\t */\n\tsize(filePath) {\n\t\treturn this.#fsp\n\t\t\t.stat(filePath)\n\t\t\t.then(stat => stat.size)\n\t\t\t.catch(error => {\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Returns the last modified date of a file or directory. This method handles ENOENT errors\n\t * and returns undefined in that case.\n\t * @param {string|URL} fileOrDirPath The path to the file to read.\n\t * @returns {Promise<Date|undefined>} A promise that resolves with the last modified\n\t * date of the file or directory, or undefined if the file doesn't exist.\n\t */\n\tlastModified(fileOrDirPath) {\n\t\treturn this.#fsp\n\t\t\t.stat(fileOrDirPath)\n\t\t\t.then(stat => stat.mtime)\n\t\t\t.catch(error => {\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Copies a file from one location to another.\n\t * @param {string|URL} source The path to the file to copy.\n\t * @param {string|URL} destination The path to copy the file to.\n\t * @returns {Promise<void>} A promise that resolves when the file is copied.\n\t * @throws {Error} If the source file does not exist.\n\t * @throws {Error} If the source file is a directory.\n\t * @throws {Error} If the destination file is a directory.\n\t */\n\tcopy(source, destination) {\n\t\treturn this.#fsp.copyFile(source, destination);\n\t}\n\n\t/**\n\t * Copies a file or directory from one location to another.\n\t * @param {string|URL} source The path to the file or directory to copy.\n\t * @param {string|URL} destination The path to copy the file or directory to.\n\t * @returns {Promise<void>} A promise that resolves when the file or directory is\n\t * copied.\n\t * @throws {Error} If the source file or directory does not exist.\n\t * @throws {Error} If the destination file or directory is a directory.\n\t */\n\tasync copyAll(source, destination) {\n\t\t// for files use copy() and exit\n\t\tif (await this.isFile(source)) {\n\t\t\treturn this.copy(source, destination);\n\t\t}\n\n\t\tconst sourceStr =\n\t\t\tsource instanceof URL ? fileURLToPath(source) : source;\n\n\t\tconst destinationStr =\n\t\t\tdestination instanceof URL\n\t\t\t\t? fileURLToPath(destination)\n\t\t\t\t: destination;\n\n\t\t// for directories, create the destination directory and copy each entry\n\t\tawait this.createDirectory(destination);\n\n\t\tfor await (const entry of this.list(source)) {\n\t\t\tconst fromEntryPath = path.join(sourceStr, entry.name);\n\t\t\tconst toEntryPath = path.join(destinationStr, entry.name);\n\n\t\t\tif (entry.isDirectory) {\n\t\t\t\tawait this.copyAll(fromEntryPath, toEntryPath);\n\t\t\t} else {\n\t\t\t\tawait this.copy(fromEntryPath, toEntryPath);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Moves a file from the source path to the destination path.\n\t * @param {string|URL} source The location of the file to move.\n\t * @param {string|URL} destination The destination of the file to move.\n\t * @returns {Promise<void>} A promise that resolves when the move is complete.\n\t * @throws {TypeError} If the file paths are not strings.\n\t * @throws {Error} If the file cannot be moved.\n\t */\n\tmove(source, destination) {\n\t\treturn this.#fsp.stat(source).then(stat => {\n\t\t\tif (stat.isDirectory()) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`EISDIR: illegal operation on a directory, move '${source}' -> '${destination}'`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn this.#fsp.rename(source, destination);\n\t\t});\n\t}\n\n\t/**\n\t * Moves a file or directory from the source path to the destination path.\n\t * @param {string|URL} source The location of the file or directory to move.\n\t * @param {string|URL} destination The destination of the file or directory to move.\n\t * @returns {Promise<void>} A promise that resolves when the move is complete.\n\t * @throws {TypeError} If the file paths are not strings.\n\t * @throws {Error} If the file or directory cannot be moved.\n\t */\n\tasync moveAll(source, destination) {\n\t\treturn this.#fsp.rename(source, destination);\n\t}\n}\n\n/**\n * A class representing a file system utility library.\n * @implements {HfsImpl}\n */\nexport class NodeHfs extends Hfs {\n\t/**\n\t * Creates a new instance.\n\t * @param {object} [options] The options for the instance.\n\t * @param {Fsp} [options.fsp] The file system module to use.\n\t */\n\tconstructor({ fsp } = {}) {\n\t\tsuper({ impl: new NodeHfsImpl({ fsp }) });\n\t}\n}\n\nexport const hfs = new NodeHfs();\n","/**\n * @fileoverview This file exports everything for this package.\n * @author Nicholas C. Zakas\n */\n\nexport * from \"./node-hfs.js\";\nexport { Hfs } from \"@humanfs/core\";\n"],"names":[],"sourceRoot":""}